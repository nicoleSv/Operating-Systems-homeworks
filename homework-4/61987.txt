Документация към домашно 4 по ОС-практикум
Изготвено от: Никол Емануилова, ФН: 61987

Основна идея:
Програмата приема точно един аргумент, който е броят на максималните паралелни
задачи. Преобразува го до променлива от тип цяло число, за да може коректно да
се използва за сравняване. След това върви цикъл, който обхожда ред по ред
задачите, които се подават на програмата на stdin. Всяка задача се подава на
функция, която се fork-ва и в новият процес обработва задачата. След всяко
пускане на задачата се увеличава брояч на текущите паралелни задачи и ако стане
равен на максималният брой, то трябва да се изчака някоя задача да приключи и 
съответно да освободи място за изпълнение на следващата. Функцията, която 
обработва задачите проверява дали й е подадена проста команда, няколко
команди разделени с ';' за последователно изпълнение или пайпнати команди, за
да извика съответната функция.

По-подробно обяснение на допълнителните функции:
    1) int to_int(char* string)
    Грижи се за преобразуването на подадения аргумент на функцията в тип цяло
    число. Проверява дали той е коректен, т.е. дали има излишни символи, които
    да доведат до некоректно преобразуване. Ако подаденият низ е коректен,
    функцията връща числото, което представя, ако не, връща -1 и програмата ще
    изведе съобщение за грешка.

    2) int read_line(char* line)
    Тази функция прочита един ред от stdin и го записва в подадения на
    функцията char* line, за който предварително е заделена памет от 1024
    байта (максималната дължина на ред). Функцията връща 1, ако е успяла да
    прочете ред, и съответно 0, ако не. Така цикълът в main функцията върви,
    докато има задачи за изпълнение.

    3) char* get_substring(char* string, int start, int end)
    Функцията връща подниз от подаден стринг, като копира от start индекс до
    end индекс. Служи като помощна функция за парсване на командите от целия
    ред, който представлява една задача. 

    4) char** split_line(char* line, char delimiter)
    Разделя стринг по даден разделител(символ), като всеки получен токен се
    записва в двумерен масив. Съответно за копирането на част от стринга, се
    ползва горната помощна функция. Връща парснатия стринг под формата на
    двумерен масив.

    5) void simple_command(char** command)
    Функцията изпълнява проста команда. Получава като параметър двумерен масив
    с командата за изпълнение и нейните аргументи, ако има такива. Накрая стои
    NULL елемент, показващ края на аргументите. Процесът се копира и в детето
    се изпълнява съответната команда. Правят се проверки при всяко системно
    извикване и, ако не е било успешно се извежда съобщение за грешка.

    6) int count_pipes(char* pipeline)
    Функцията проверява дали в дадена задача има пайпове, тоест символ '|'.
    Ако не намери такъв символ, връща 0, тоест ще се изпълнява проста команда.
    Ако във задачата присъства '|', то се брои колко пъти се среща, защото
    програмата поддържа произволен брой пайпове. Този брой е стойността, която
    функцията връща.

    7) char*** split_pipes(char* pipeline)
    Тази функция се вика, когато се установи, че задачата за изпълнение
    съдържа пайпове. Както пише по-горе, всяка команда и аргументите и
    се съхраняват в двумерен масив. По тази причина, за да се реализира
    успешно изпълняване на произволен брой пайпнати команди, то всички
    те се съхраняват в двумерен масив. Тази функция създава такъв, с размер
    брой на пайповете (върнат от горната функция) +2 (+1, защото командите са
    броя на '|' +1, и още +1 за NULL). Функцията обхожда низа на задачата и
    при всяко срещане на пайп, вика функцията get_substring, за да вземе
    командата, след което със split_line се разделя по whitespace и резултатът
    се записва в тримерния масив. Налага се процедурата да се направи още
    веднъж след приключването на цикъла, който обхожда низа, за да не се
    пропуска и последната команда. Функцията връща получения тримерен масив,
    от който да бъдат изпълнени пайпнатите команди.

    8) void multiple_pipes(char*** commands)
    Това е функцията, която осъществява пускането на произволен брой команди,
    който комуникират чрез тръба, тоест изхода на едната е входа на следващата
    команда. Пуска се цикъл, който обхожда всяка една команда. На всяка стъпка
    процесът се fork-ва. В детето файловият дескриптор 0 се затваря и на
    място се копира fd_in, който ще се ползва за запазване на изхода. Тоест
    това е съществено за следващите команди. След това се затваря файловият
    дескриптор 1 (stdout), и на негово място се копира края на тръбата за
    писане, а краят за четене от тръбата се затваря. След като са нагласени
    краищата на тръбата се exec-ва текущата команда. В родителя се изчаква
    процесът да приключи и се затваря краят за писане, защото не е нужен, а ще
    се ползва този за четене. Той се копира във fd_in, за да може да се запази
    изхода на изпълнената команда и да се подаде на следващата, както написах
    и по-рано. След това се минава на следвщата стъпка от цикъла и така,
    докато се изпълнят всички пайпнати команди. Идеята за това решение с
    произволен брой пайпове видях от следния гитхъб:
    https://gist.github.com/iomonad/a66f6e9cfb935dc12c0244c1e48db5c8

    9) void process_line(char* input)
    Това е основната функция, която се справя с пускането на команди. За да се
    осъществи паралелното пускане на команди тук отново процесът се fork-ва.
    По този начин за всяка задача се грижи отделен процес и не си пречат
    взаимно с изчакването.
    Първоначално подадения ред (задачата) се разделя по ';'. Така лесно се
    постига последователността на изпълнение, която изисква този разделител.
    След това се обхождат получените команди в двумерен масив. Проверява се
    дали има пайпове в получените низове, ако да, се вика функция да парсне
    низа по '|', за което е специалната функция split_pipes и после се
    изпълняват чрез mutliple_pipes. Ако пък е проста команда, низът се сплитва
    по whitespace, след което се изпълнява.

main:

В main функцията върви цикъл, който обхожда ред по ред, докато има задачи.
Следи се чрез променливата current_tasks колко паралелни задачи са пуснати
в момента, и ако този брой стане равен на максималният брой, подаден на
програмата, то процесът чака, която и да е задача да приключи, за да освободи
място. Също така, периодично се проверява с опцията WNOHANG дали някоя задача
не е приключила (ако състоянието не е променено, то процесът не заспива). Така
се поддържа коректен брой на текущите задачи, дори и да не е достигнат макс.
Брои се и колко са всички изпълнени задачи, след което се пуска цикъл с точно
толкова стъпки да изчака всяка една задача да приключи. Това изпълнява 
условието главния процес да не се терминира, преди да са изпълнени всички
задачи.
