Документация към домашно 2 по ОС-практикум
Изготвено от: Никол Емануилова, ФН: 61987

1) download.sh
Скриптът прави провеки дали са му подадени точно два аргумента, дали вторият е
линк към отчети от състезание на Българската федерация на радиолюбителите, като
извежда подходящо съобщение за грешка, ако не са изпълнени тези условия. В
задачата не е уточнено дали задължително съществува подадената директория, 
затова скриптът проверява дали това е така и ако не, то създава такава директория.
Инструментът, който ползвам за теглене на файловете е lftp, затова се проверява дали той е
инсталиран на машината и ако не е, извежда съобщение, което съветва как да се
инсталира и прекратява скрипта. Този инструмент открих след търсене на подходящ
такъв в Интернет и го намерих на следния сайт:
https://lftp.yar.ru/lftp-man.html , като всъщност е публикувана ман
страницата на този инструмент.
Самото теглене се осъществява чрез командата mirror към lftp, която запазва
съдържанието на подадения линк в локалната директория. В условието пише да
изтеглим файловете в удобен за нас вид, затова скриптът тегли файловете в
директория
с името на годината на състезанието, която има в линка(пр. 2017). Съответно
тази директория ще се намира в подадената на скрипта. По този начин осигурявам,
че в тази директория няма да има излишни файлове, а само отчети от
състезанието.
След приключване на тегленето се извежда съобщение, че е било успешно.

2) competition.sh
Този скрипт също прави проверка дали са му подадени точно два аргумента, както
и дали първият е съществуваща директория(предполага се, че скриптът се извиква след като
файловете са изтеглени с download.sh, затова подадената директория трябва да
съществува). След това проверява дали е подадена валидна функция като втори
аргумент. Ако да, то я извиква с параметър директорията(всички функции приемат
такъв параметър), а ако не, извежда
подходящо съобщение за грешка.

    a) participants
    Тази функция трябва да изведе позивните на участниците в състезанието, т.е. тези, за
    които съществуват отчети. Тъй като чрез предния скрипт е подсигурено, че в
    подадената директория с отчети има само такива файлове, то за тази задача е
    достатъчно само да изведем имената на файловете в нея. За по-добра
    ориентация, те биват изведени сортирани лексикографски.

    б) outliers
    Тази фунцкия извежда позвините, които се срещат в отчети, но не са реални
    участници или по-точно нямаме отделен отчет за тях. Използва се for цикъл,
    който обхожда една по една всяка позивна, която се среща и проверява дали
    съществува файл с такова име. Съответно, ако не съществува, значи това не
    е реален участник и се изписва позивната му. Всички възможни позивни се намират
    като се конкатенират всички файлове(подсигурява се с -maxdepth 1 -mindepth
    1, че търсим файлове само в текущата директория) и се вземат само тези редове, които
    започват с "QSO:" и от тях е нужна деветата колона, защото там стоят имената
    на кореспондентите. Сортират се, за да може да се премахне дублирането, а
    не да се проверяват по няколко пъти. В някои файлове позивните завършват с
    '\r', а в други не - така се приемат като различни имена. За да се
    сравняват коректно, се изтрива, ако има '\r' в края. Също така забелязах,
    че някои позивни са изписани грешно, тоест имат различни символи в тях,
    както и малки букви(по условие трябва да са главни латински букви и цифри).
    Затова използвам tr, за да направя всички валидни и да може да се търси
    нужната информация коректно.

    в) unique
    Целта на тази функция е да изведе позивните, които се срещат в 3 или
    по-малко отчета. Отново с for цикъл се обхождат всички възможни
    позивни(включително и тези, които outliers извежда, защото в условието не е
    пояснено дали трябва да се игнорират). За
    да преброи в колко отчета се среща всяка, се използва
    това, че в директорията има само такива файлове. С egrep -l | wc -l се
    проверява в колко файла се среща дадената позивна, като се търси във всеки
    един от подадената директория(egrep с опцията -l извежда в кои файлове
    намира съвпадение, а не самите редове, които отговарят на шаблона). Съответно, ако броят е
    3 или по-малко, то позивната се извежда.

    г) cross_check
    Функцията извежда редовете, за които няма съответстващ запис в отчета на
    кореспондента, като трябва да съвпадат датата и часът на връзка. С два
    while цикъла се обхождат всички файлове в директорията и съответно
    съдържанието на всеки един, или по-точно редовете, в които са записани дата
    и час на връзка, както и име на кореспондент. Неговата позивна се взима от
    деветата колона, транслира се до валидно име(поради обяснението и на
    горните функции за излишни символи в някои позивни) и се проверява дали
    съществува файл с такова име. Това се налага,
    защото ако не е така, то това не е реален участник и няма отделен отчет за
    него. Запис за връзка с нереален участник не е смислен
    и няма място в изхода от тази функция, но в мудъл е написано
    да извеждаме и тези редове, затова скрипта директно ги извежда, ако не
    намери съществуващ отчет.
    Ако кореспондентът е реален, се взима датата и часът от текущия файл и с awk
    се проверява за съответствие в острещния отчет. Awk преброява записите,
    които отговарят на условието, тоест ако накрая броячът е 0, то не е намерен
    съответсващ запис и този ред трябва да бъде изведен.

    д) bonus
    Тази функция допълва cross_check с позволена грешка от 3 или по-малко
    минути разлика във времето на записите. Аналогично се обхождат файловете и
    тяхното съдържание. Разликата, която се появява е в начина, по който awk
    сравнява двата отчета. Дефинира се функция abs, за да се вземе абсолютната
    стойност на разликата между часовете и да няма проблем с отрицателните
    резултати. Взима се времето от записа, тоест петата колона. Тъй като е в
    неподходящ формат за сравняване, то първите две цифри се умножават по 60 и
    към тях се добавят другите две, тоест времето се преобразува в минути за
    по-лесна проверка. Намира се разликата от преобразуваните стойности на
    петата колона в двата отчета, и ако тя е по-малка или равна на 3(минути),
    то броячът се увеличава. Аналогично на горната функция, ако не се намери
    такъв запис в отсрещния отчет(тоест разликата във времето е прекалено
    голяма или изобщо не съществува запис), то броячът е 0 и редът се извежда.
