Документация към домашно 3 по ОС-практикум
Изготвено от: Никол Емануилова, ФН: 61987

Условието на задачата изисква търсене на дума във файл и извеждане на нейното описание, като за максимален брой точки се изисква логаритмична сложност на обхождане на подадения файл. Затова моето решение реализира двоично търсене във файл. За неговото постигане са дефинирани 3 помощни функции:
    1) int find_word(int fd, int position)
    -Тази функция намира позицията на следващия запис от речника, според текущата позиция на указателя за четене във файла. С lseek се подсигурява, че четенето започва от подадената позиция. Чете байт по байт, докато не стигне до нулев знак '\0', което означава, че след него има дума(според условието), като в променливата count се запазва колко байта са обходени, за да се стигне до думата.
    -Функцията връща сумата от подадената му позиция + стойността на count, т.е. това е позицията, от която трябва да почне да се чете запис от файла. Това помага да намерим думата от записа и да я сравним с търсената дума, която е аргумент на програмата.
    -Функцията приема като аргументи файловия дескриптор, с който да чете от файла, подаден на програмата, както и позицията, от която да започне да търси следващ запис.

    2) int str_length(int fd, int position, char delimiter)
    -Идеята на тази функция е да намери дължината на дума или на нейното описание. Тоест след като сме установили позицията, от която започва дадена дума, то я подаваме като аргумент на тази функция, а като delimiter се подава '\n', тъй като знаем, че думата се намира между нулев символ и символ за нов ред. Аналогично за описанието й се подава позицията, от която то започва(тоест след въпросния нов ред) и като delimiter се подава '\0'(описанието приключва до този символ, защото след него започва следващият запис).
    -Функцията връща дължината на търсения символен низ, като това число се използва да се задели динамично памет за прочитането на думата или описанието й.

    3) void free_resources(int fd, char* word, char* translation)
    -Тази функция се използва при излизане от програмата: затваря файловият дескриптор и освобождава динамично заделената памет. Тъй като това може да се наложи в доста случаи и не винаги се е стигнало до заделянето на динамична памет за дума или за нейното описание, функцията първо проверява дали изобщо има такава и чак тогава се опитва да я освободи. Съответно проверява и дали успешно се е затворил файловият дескриптор.

main:

Прави се проверка дали програмата е получила нужния брой аргументи, т.е. 2: име на файл и дума. Също така за всяко системно извикване(open, close, read, write, ...) се проверява дали е изпълнено правилно и ако не, програмата приключва с подходящо съобщение и exit status:
    exit status 1 - некоректен брой подадени параметри
    exit status 2 - неуспешен опит за отваряне на файлов дескриптор към файла
    exit status 3 - неуспешен опит за четене от файла
    exit status 4 - неуспешно затваряне на файловия дескриптор за четене от файла
    exit status 5 - неуспешен опит за писане на STDOUT
    exit status 6 - не е намерена търсената дума в речника

Описание на алгоритъма на решението:

Реализирам двоично търсене във файла за постигане на логаритмична сложност. Двоичното търсене представлява алгоритъм от типа "разделяй и владей", като е уместно да се прилага само за сортирани елементи. Първо се проверява за съответствие със средния елемент. Ако това не е търсеният, то се преценява в коя половина да продължи търсенето и така рекурсивно, докато не се открие търсеният елемент или не се установи, че го няма. Това е възможно да се приложи и в тази задача, защото според условието сме сигурни, че файлът е лексикографски сортиран.
Чрез преместването на lseek в края на файла, се разбира какъв е неговият размер. Тъй като няма фиксиран размер на редовете или друга подобна информация, след като просто се раздели размера на файла, който е брой байтове, на 2, то няма гаранция къде във файла се намира. Използва се допълнителната функция, за да се предвижим напред до началото на дума, намира се дължината й и се създава масив с такава големина, за да я запишем в него и това да бъде нашият среден елемент за сравняване. Ако това е търсената дума, то по аналогичен начин се намира дължината на описанието й, запазва се в подходящ масив, след което се изписва на екрана. Щом думата е намерена, цикълът се прекъсва и програмата излиза с exit status 0. Ако не е, то в зависимост какво връща функцията strcmp(отрицателно или положително число), смаляваме областта от байтове, в която ще търсим и повтаряме стъпките. И така цикълът продължава, докато разликата между границите е 1, т.е. са останали елементи за сравняване. Ако приключи без да е намерено съответствие, то програмата изписва съобщение за липсата на думата и приключва с подходящ exit status.
Проблемът при този алгоритъм е, че ако търсената дума е първа в речника, то никога няма да се стигне до нея. Дължи се на това, че когато с lseek попаднем на място между буквите, което не е начало на дума, то се движим винаги напред, за да стигнем до такава. Тоест колкото и малка да става областта, то алгоритъмът винаги ще стига до втората дума от речника в този частен случай. Затова се налага първо да проверим дали подадената дума не е първа в речника. Ако е така,то се изписва описанието й и програмата приключва, без изобщо да влиза в цикъла за търсене. Съответно ако установи, че се търси друга дума, започва двоичното търсене. 
